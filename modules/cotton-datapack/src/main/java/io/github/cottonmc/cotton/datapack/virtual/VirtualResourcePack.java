package io.github.cottonmc.cotton.datapack.virtual;

import com.google.common.collect.ImmutableMap;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import io.github.cottonmc.cotton.datapack.util.Identifiers;
import net.minecraft.SharedConstants;
import net.minecraft.resource.AbstractFileResourcePack;
import net.minecraft.resource.ResourceType;
import net.minecraft.resource.metadata.ResourceMetadataReader;
import net.minecraft.util.Identifier;
import net.minecraft.util.InvalidIdentifierException;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * A virtual resource pack that is not represented by actual files.
 */
public class VirtualResourcePack extends AbstractFileResourcePack {
	private static final int PACK_FORMAT = SharedConstants.getGameVersion().getPackVersion();
	private static final Logger LOGGER = LogManager.getLogger();
	private static final Pattern NAMESPACE_PATTERN = Pattern.compile("(?:.+?)/(.+?)/.+");
	private final Set<String> namespaces;
	private final Map<String, InputStreamProvider> contents;
	private final Identifier id;

	/**
	 * The constructor.
	 *
	 * @param id       a unique identifier for this data pack
	 * @param contents the contents as a [resource path]=>[contents] map
	 */
	public VirtualResourcePack(Identifier id, Map<String, InputStreamProvider> contents) {
		super(null);
		this.id = id;
		this.namespaces = contents.keySet().stream()
				.map(path -> {
					Matcher matcher = NAMESPACE_PATTERN.matcher(path);
					if (matcher.find()) {
						return matcher.group(1);
					} else {
						LOGGER.warn("Resource path {} in virtual resource pack {} might not be valid", path, id);
						return null;
					}
				})
				.filter(Objects::nonNull)
				.collect(Collectors.toSet());
		this.contents = contents;
	}

	/**
	 * A deprecated constructor. Use {@link #VirtualResourcePack(Identifier, Map)} instead.
	 *
	 * @param id       an identifier for this data pack (does not have to be unique)
	 * @param contents the contents as a [resource path]=>[contents] map
	 */
	@Deprecated
	public VirtualResourcePack(String id, Map<String, InputStreamProvider> contents) {
		this(convertToUniqueId(id), contents);
	}

	@Override
	protected InputStream openFile(String s) throws IOException {
		if (contents.containsKey(s)) return contents.get(s).create();
		else throw new FileNotFoundException("Unknown file in virtual resource pack: " + s);
	}

	@Override
	protected boolean containsFile(String s) {
		return contents.containsKey(s);
	}

	@Override
	public Collection<Identifier> findResources(ResourceType type, String namespace, String path, int depth, Predicate<String> predicate) {
		List<Identifier> ids = new ArrayList<>();
		Set<String> contentKeys = contents.keySet();

		String prefix = String.format("%s/%s/%s", type.getDirectory(), namespace, path);
		Stream<String> matchingKeys = contentKeys.stream().filter(s -> s.startsWith(prefix));
		matchingKeys.map(s -> s.split("/"))
				.filter(split -> predicate.test(split[split.length - 1]))
				.forEach(split -> {
					try {
						ids.add(new Identifier(namespace, String.join("/", ArrayUtils.subarray(split, 2, split.length))));
					} catch (InvalidIdentifierException e) {
						LOGGER.error("Invalid identifier found in virtual resource pack", e);
					}
				});


		return ids;
	}

	@Override
	public Set<String> getNamespaces(ResourceType resourceType) {
		return namespaces;
	}

	@Override
	public void close() {
	}

	@Override
	public String getName() {
		return String.format("%s (virtual)", id);
	}

	/**
	 * @return the id of this resource pack
	 */
	public Identifier getId() {
		return id;
	}

	@Override
	public <T> T parseMetadata(ResourceMetadataReader<T> reader) {
		JsonObject packMetadata = new JsonObject();
		packMetadata.addProperty("pack_format", PACK_FORMAT);
		packMetadata.addProperty("description", "Virtual resource pack generated by Cotton.");

		JsonObject metadata = new JsonObject();
		metadata.add("pack", packMetadata);

		if (metadata.has(reader.getKey())) {
			try {
				return reader.fromJson(metadata.getAsJsonObject(reader.getKey()));
			} catch (JsonParseException e) {
				LOGGER.error("Couldn't load {} metadata from virtual resource pack", reader.getKey(), e);
			}
		}

		return null;
	}

	/**
	 * Gets the contents of this pack as a file path -> input stream provider map.
	 *
	 * @return the contents
	 */
	public ImmutableMap<String, InputStreamProvider> getContents() {
		return ImmutableMap.copyOf(contents);
	}

	/*
	 Everything below is used to make unique identifiers for the deprecated constructor.
	 The constructor tries to convert the old ids to identifiers as well as possible
	 (also adding the index in the end to make them unique).
	*/

	/**
	 * Converts the input string into a unique pack identifier.
	 *
	 * @param str the input string
	 * @return a unique pack id
	 */
	private static Identifier convertToUniqueId(String str) {
		Identifier result = Identifier.tryParse(str);

		if (result == null) {
			result = new Identifier("unknown", filterValidIdChars(str));
		}

		int index = VirtualResourcePackManager.INSTANCE.getPackIds().size();
		return Identifiers.suffixPath(result, "_" + index);
	}

	/**
	 * Filters the input string by checking each character
	 * with {@link #isValidIdChar(char)}.
	 *
	 * @param str the string
	 * @return a filtered string
	 */
	private static String filterValidIdChars(String str) {
		StringBuilder result = new StringBuilder();

		for (char c : str.toCharArray()) {
			if (isValidIdChar(c)) {
				result.append(c);
			}
		}

		return result.toString();
	}

	/**
	 * Returns true if the character is a valid character
	 * for an identifier namespace.
	 *
	 * @param c the character
	 * @return true if the character is valid for an id namespace
	 */
	private static boolean isValidIdChar(char c) {
		// a-z0-9_.-
		return c == '.' || c == '-' || c == '_' ||
				(c >= 'a' && c <= 'z') ||
				(c >= '0' && c <= '9');
	}
}
